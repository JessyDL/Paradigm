<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>paradigm engine: core::gfx::buffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">paradigm engine
   </div>
   <div id="projectbrief">custom C++17 Vulkan engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcore_1_1gfx_1_1buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcore_1_1gfx_1_1buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">core::gfx::buffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>maps a memory region and interfaces with the driver for read/writes  
 <a href="classcore_1_1gfx_1_1buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_2inc_2vk_2buffer_8h_source.html">buffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcore_1_1gfx_1_1buffer_1_1commit__instruction.html">commit_instruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">description of a memory commit instruction. Tries to offer some safer mechanisms.  <a href="structcore_1_1gfx_1_1buffer_1_1commit__instruction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a180a6ef07535a02b9ad139c3e4886edf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a180a6ef07535a02b9ad139c3e4886edf">buffer</a> (const <a class="el" href="struct_u_i_d.html">UID</a> &amp;uid, <a class="el" href="classcore_1_1resource_1_1cache.html">core::resource::cache</a> &amp;cache, <a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1context.html">core::gfx::context</a> &gt; <a class="el" href="classcore_1_1gfx_1_1context.html">context</a>, <a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1data_1_1buffer.html">core::data::buffer</a> &gt; buffer_data, std::optional&lt; <a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1buffer.html">core::gfx::buffer</a> &gt;&gt; staging_buffer=std::nullopt)</td></tr>
<tr class="memdesc:a180a6ef07535a02b9ad139c3e4886edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a buffer from the given buffer_data, as well as optionally sets a staging resource.  <a href="#a180a6ef07535a02b9ad139c3e4886edf">More...</a><br/></td></tr>
<tr class="separator:a180a6ef07535a02b9ad139c3e4886edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0213f926a8bfd4bc15b6f2f8ffa6b1d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0213f926a8bfd4bc15b6f2f8ffa6b1d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b> (const <a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &amp;)=delete</td></tr>
<tr class="separator:a0213f926a8bfd4bc15b6f2f8ffa6b1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ba58f37dc317a412f16e5a8ae64dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c2ba58f37dc317a412f16e5a8ae64dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b> (<a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a0c2ba58f37dc317a412f16e5a8ae64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a7ca6b70e8900970716b86b914cef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a7ca6b70e8900970716b86b914cef2"></a>
<a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &amp;)=delete</td></tr>
<tr class="separator:a44a7ca6b70e8900970716b86b914cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faf9846a1c8e1714bce11e99aff44d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0faf9846a1c8e1714bce11e99aff44d8"></a>
<a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a0faf9846a1c8e1714bce11e99aff44d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae499bbfdb86f7fb33aedfb669fad683a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmemory_1_1segment.html">memory::segment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#ae499bbfdb86f7fb33aedfb669fad683a">reserve</a> (vk::DeviceSize size)</td></tr>
<tr class="memdesc:ae499bbfdb86f7fb33aedfb669fad683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to reserve a region of memory of <em>at least</em> the given size in thye buffer.  <a href="#ae499bbfdb86f7fb33aedfb669fad683a">More...</a><br/></td></tr>
<tr class="separator:ae499bbfdb86f7fb33aedfb669fad683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e17dad2ce8a0b562f7ecba2178aef6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="classmemory_1_1segment.html">memory::segment</a>, <br class="typebreak"/>
<a class="el" href="classmemory_1_1range.html">memory::range</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#aa2e17dad2ce8a0b562f7ecba2178aef6">reserve</a> (std::vector&lt; vk::DeviceSize &gt; sizes, bool optimize=false)</td></tr>
<tr class="memdesc:aa2e17dad2ce8a0b562f7ecba2178aef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to reserve all requested sizes in the <a class="el" href="classmemory_1_1region.html" title="defines a region of memory that might be physically backed depending on the allocator. ">memory::region</a> of this buffer.  <a href="#aa2e17dad2ce8a0b562f7ecba2178aef6">More...</a><br/></td></tr>
<tr class="separator:aa2e17dad2ce8a0b562f7ecba2178aef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa9fe61eab8f498a9224d885ec84cf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a1fa9fe61eab8f498a9224d885ec84cf7">commit</a> (std::vector&lt; <a class="el" href="structcore_1_1gfx_1_1buffer_1_1commit__instruction.html">commit_instruction</a> &gt; instructions)</td></tr>
<tr class="memdesc:a1fa9fe61eab8f498a9224d885ec84cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">tries to find the appropriate method to update the buffer with the commit instructions.  <a href="#a1fa9fe61eab8f498a9224d885ec84cf7">More...</a><br/></td></tr>
<tr class="separator:a1fa9fe61eab8f498a9224d885ec84cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24be29ede5663407ce919525a5f64b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#af24be29ede5663407ce919525a5f64b9">deallocate</a> (<a class="el" href="classmemory_1_1segment.html">memory::segment</a> &amp;segment)</td></tr>
<tr class="memdesc:af24be29ede5663407ce919525a5f64b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">marks the specific region of memory available again.  <a href="#af24be29ede5663407ce919525a5f64b9">More...</a><br/></td></tr>
<tr class="separator:af24be29ede5663407ce919525a5f64b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3aaca937d0128110066efa50c33d318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#ae3aaca937d0128110066efa50c33d318">copy_from</a> (const <a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &gt; &amp;other, const std::vector&lt; vk::BufferCopy &gt; &amp;copyRegions)</td></tr>
<tr class="memdesc:ae3aaca937d0128110066efa50c33d318"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows you to copy from one buffer into another.  <a href="#ae3aaca937d0128110066efa50c33d318">More...</a><br/></td></tr>
<tr class="separator:ae3aaca937d0128110066efa50c33d318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f3e85848fb1919bd6684247314265c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02f3e85848fb1919bd6684247314265c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (const void *<a class="el" href="classcore_1_1gfx_1_1buffer.html#a8887f02448293dcd4cc530bb8a5e3b90">data</a>, std::vector&lt; vk::BufferCopy &gt; commands)</td></tr>
<tr class="separator:a02f3e85848fb1919bd6684247314265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae327028a38828cfde68fd813c6cb9982"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#ae327028a38828cfde68fd813c6cb9982">is_busy</a> () const </td></tr>
<tr class="separator:ae327028a38828cfde68fd813c6cb9982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6333a7fa1d58ef35c44f604147393ce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6333a7fa1d58ef35c44f604147393ce6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a6333a7fa1d58ef35c44f604147393ce6">wait_until_ready</a> (uint64_t timeout=UINT64_MAX) const </td></tr>
<tr class="memdesc:a6333a7fa1d58ef35c44f604147393ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">forcibly wait until all operations are done, or the timeout has been reached. <br/></td></tr>
<tr class="separator:a6333a7fa1d58ef35c44f604147393ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477db5ad83ad0324e6d141b7a298bfab"><td class="memItemLeft" align="right" valign="top">std::optional<br class="typebreak"/>
&lt; <a class="el" href="classcore_1_1resource_1_1handle.html">resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a477db5ad83ad0324e6d141b7a298bfab">copy_to_host</a> (bool compressed_copy=true) const </td></tr>
<tr class="memdesc:a477db5ad83ad0324e6d141b7a298bfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the buffer available on the host.  <a href="#a477db5ad83ad0324e6d141b7a298bfab">More...</a><br/></td></tr>
<tr class="separator:a477db5ad83ad0324e6d141b7a298bfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937221ca3996089bb8b9a6ca2c3fcb7c"><td class="memItemLeft" align="right" valign="top">std::optional<br class="typebreak"/>
&lt; <a class="el" href="classcore_1_1resource_1_1handle.html">resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a937221ca3996089bb8b9a6ca2c3fcb7c">copy_to_host</a> (const std::vector&lt; vk::BufferCopy &gt; &amp;copyRegions) const </td></tr>
<tr class="memdesc:a937221ca3996089bb8b9a6ca2c3fcb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes the buffer available on the host.  <a href="#a937221ca3996089bb8b9a6ca2c3fcb7c">More...</a><br/></td></tr>
<tr class="separator:a937221ca3996089bb8b9a6ca2c3fcb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b2b906cbeaaa3321f4e9ac19d42ad5"><td class="memItemLeft" align="right" valign="top">const vk::Buffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#ac7b2b906cbeaaa3321f4e9ac19d42ad5">gpu_buffer</a> () const </td></tr>
<tr class="separator:ac7b2b906cbeaaa3321f4e9ac19d42ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8887f02448293dcd4cc530bb8a5e3b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a><br class="typebreak"/>
&lt; <a class="el" href="classcore_1_1data_1_1buffer.html">core::data::buffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a8887f02448293dcd4cc530bb8a5e3b90">data</a> () const </td></tr>
<tr class="separator:a8887f02448293dcd4cc530bb8a5e3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d9b083a1010fcdb922f5252ee3a896"><td class="memItemLeft" align="right" valign="top">vk::DescriptorBufferInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1gfx_1_1buffer.html#a91d9b083a1010fcdb922f5252ee3a896">buffer_info</a> ()</td></tr>
<tr class="separator:a91d9b083a1010fcdb922f5252ee3a896"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>buffers are used to map regions of memory that the driver should know about, either because they will be used to map GPU resources (geometry, textures, etc..), or because they are used for synchronising information between CPU/GPU (compute results). This class will handle most of the needs for synchonising, and how-to upload the data to the relevant locations as well as managing the internals. </p>

<p>Definition at line <a class="el" href="core_2inc_2vk_2buffer_8h_source.html#l00019">19</a> of file <a class="el" href="core_2inc_2vk_2buffer_8h_source.html">buffer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a180a6ef07535a02b9ad139c3e4886edf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::gfx::buffer::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_i_d.html">UID</a> &amp;&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore_1_1resource_1_1cache.html">core::resource::cache</a> &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1context.html">core::gfx::context</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1data_1_1buffer.html">core::data::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>buffer_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1buffer.html">core::gfx::buffer</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>staging_buffer</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_data</td><td>the data source to bind to this buffer. (see note for more info) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">staging_buffer</td><td>the staging buffer to use in case staging is needed. (see warning for more info) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>it is recommended to give a staging_buffer unless you know this is a host-only resource. failing to give a staging resource to a device-local region that cannot be accessed by the host will result in performance degradation as it has to keep making temporary staging buffers instead. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>buffer_data dictates the size, and alignment of this buffer resource. In the event that the allignment is incorrect, a suitable warning (and potential override) will be supplied. If the supplied buffer_data is non-virtual (i.e. backed by real memory location), then the resource will be duplicated and accessible for read access through the <a class="el" href="classcore_1_1data_1_1buffer.html" title="container class for GPU data. ">core::data::buffer</a> handle directly. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae499bbfdb86f7fb33aedfb669fad683a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmemory_1_1segment.html">memory::segment</a> &gt; buffer::reserve </td>
          <td>(</td>
          <td class="paramtype">vk::DeviceSize&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the minimum size to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classmemory_1_1segment.html" title="a segment defines a addressable and mapped region of memory. ">memory::segment</a> on success. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00106">106</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2e17dad2ce8a0b562f7ecba2178aef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classmemory_1_1segment.html">memory::segment</a>, <a class="el" href="classmemory_1_1range.html">memory::range</a> &gt; &gt; buffer::reserve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; vk::DeviceSize &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>optmized version of <a class="el" href="classcore_1_1gfx_1_1buffer.html#ae499bbfdb86f7fb33aedfb669fad683a" title="tries to reserve a region of memory of at least the given size in thye buffer. ">reserve()</a> that works on a batch of data. It will try to satisfy allocating regions of memory of atleast the given accumulative size. Depending on the optimize boolean parameter's value this can be in one optimized <a class="el" href="classmemory_1_1segment.html" title="a segment defines a addressable and mapped region of memory. ">memory::segment</a> (true), or in equal amount of memory::segments as there were elements in the sizes requested container (false). when optimize is true, the returned <a class="el" href="classmemory_1_1range.html" title="defines a begin/end location in (virtual) memory (in respect to the region, or segment). ">memory::range</a> in the pair signifies the offset from the start of the segment (where the actual memory you requested resides). when optimize is false, range always starts at 0, and ends at the actual allocated size. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector with as many contained elements as the requested sizes container has. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>a container with minimum sizes you want to request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optimize</td><td>signifies if we should we try to collapse multiple memory::segments into one segment if possible, avoiding fragmentation and overhead. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00108">108</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1fa9fe61eab8f498a9224d885ec84cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool buffer::commit </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcore_1_1gfx_1_1buffer_1_1commit__instruction.html">commit_instruction</a> &gt;&#160;</td>
          <td class="paramname"><em>instructions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this method tries to commit the given instruction into the buffer. depending on the type of buffer how this does that can differ greatly. </p>
<dl class="section warning"><dt>Warning</dt><dd>if the buffer is device local and no staging buffer is known, it will try to create a staging buffer to facilitate transfers this has a performance overhead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instructions</td><td>all the instructions you wish to send to the GPU in this batch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success if the instruction has been sent. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this method will try to figure out the best way to send this set of instructions to the GPU, possibly merging instructions together. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00162">162</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af24be29ede5663407ce919525a5f64b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool buffer::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmemory_1_1segment.html">memory::segment</a> &amp;&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">segment</td><td>the region you wish to free up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success in case the region was freed. note that in case the buffer was not the owner of the <a class="el" href="classmemory_1_1segment.html" title="a segment defines a addressable and mapped region of memory. ">memory::segment</a>, false will be returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>no actual memory will be freed. driver resources are created at the start (constructor) and can only be freed completely (destructor). there is no intermediate unless you copy over the resources to a new, smaller buffer. Check <a class="el" href="classcore_1_1gfx_1_1buffer.html#ae3aaca937d0128110066efa50c33d318" title="allows you to copy from one buffer into another. ">copy_from()</a> for that. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00272">272</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3aaca937d0128110066efa50c33d318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool buffer::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vk::BufferCopy &gt; &amp;&#160;</td>
          <td class="paramname"><em>copyRegions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the buffer to copy from into this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copyRegions</td><td>the batch of copy instructions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case the instructions were successfully uploaded to the GPU. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00342">342</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae327028a38828cfde68fd813c6cb9982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool buffer::is_busy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>in case the GPU/driver is busy. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>could be true for various situations, in case it is busy uploading, or hasn't finalized everything yet amongst other. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00490">490</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a477db5ad83ad0324e6d141b7a298bfab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classcore_1_1resource_1_1handle.html">resource::handle</a>&lt;<a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a>&gt; &gt; core::gfx::buffer::copy_to_host </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed_copy</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compressed_copy</td><td>when compressed is true, then the buffer will collapse all empty regions and return a buffer that is the size of all actual committed memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a HOST_VISIBLE buffer on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a937221ca3996089bb8b9a6ca2c3fcb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classcore_1_1resource_1_1handle.html">resource::handle</a>&lt;<a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a>&gt; &gt; core::gfx::buffer::copy_to_host </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; vk::BufferCopy &gt; &amp;&#160;</td>
          <td class="paramname"><em>copyRegions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyRegions</td><td>the regions the new buffer will consist out of. The new buffer will be the size of the accumulate size of the copyRegions (+ alignment rules). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a HOST_VISIBLE buffer on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7b2b906cbeaaa3321f4e9ac19d42ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vk::Buffer &amp; buffer::gpu_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vk::Buffer handle. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00500">500</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8887f02448293dcd4cc530bb8a5e3b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcore_1_1resource_1_1handle.html">core::resource::handle</a>&lt; <a class="el" href="classcore_1_1data_1_1buffer.html">core::data::buffer</a> &gt; buffer::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the internal buffer data. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00501">501</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91d9b083a1010fcdb922f5252ee3a896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::DescriptorBufferInfo &amp; buffer::buffer_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vulkan descriptor buffer info. </dd></dl>

<p>Definition at line <a class="el" href="vk_2buffer_8cpp_source.html#l00502">502</a> of file <a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/JessyDL/paradigm/core/inc/vk/<a class="el" href="core_2inc_2vk_2buffer_8h_source.html">buffer.h</a></li>
<li>/home/travis/build/JessyDL/paradigm/core/src/vk/<a class="el" href="vk_2buffer_8cpp_source.html">buffer.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecore.html">core</a></li><li class="navelem"><a class="el" href="namespacecore_1_1gfx.html">gfx</a></li><li class="navelem"><a class="el" href="classcore_1_1gfx_1_1buffer.html">buffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
